#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/crypto.h>
#include "openssl/ssl.h"
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <openssl/obj_mac.h>
#include <openssl/rand.h>
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>

int main() {
    // 初始化 OpenSSL 库
    if (OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL) == 0) {
        fprintf(stderr, "Failed to initialize OpenSSL\n");
        return 1;
    }

//---------------- 创建 BIGNUM 对象-------------//
    BIGNUM* a = BN_new();
    BIGNUM* b = BN_new();
    BIGNUM* c = BN_new();
    BIGNUM* mont_a = BN_new();
    BIGNUM* mont_b = BN_new();
    BIGNUM* rand_a = BN_new();
    BIGNUM* rand_b = BN_new();
    BIGNUM* p = BN_new();
    BIGNUM* m = BN_new();
    BIGNUM* r = BN_new();
    BIGNUM* r0 = BN_new();
    BIGNUM* moood = BN_new();
    BN_MONT_CTX* mont= BN_MONT_CTX_new();
    BIGNUM* rand_num = BN_new();//二进制域
    BIGNUM* modulus = BN_new();//二进制域
//-------------创建 BN_CTX 对象----------------//
    BN_CTX* ctx = BN_CTX_new();
    //BN_MONT_CTX* BN_MONT_CTX_new(void);
	
//----------------------------输入定义------------------------------------//
	BN_hex2bn(&a, "023E5DA79ACFD5221DD36CA7C69942FFB878734E2CAA6D3E3ADC35BDB579E53DC448471E");
	BN_hex2bn(&b, "07C554D3F1CB264131371922C13A3AC900AE8899567AF21E5AA74AE2656A33B14FC56039");
	//BN_hex2bn(&c, "01");
	//BN_hex2bn(&a, "4000FF00D5D5D5D5D5D5D5BFFFFFCDCDCDCD920000000000001A1A1A1AFF000001FFFFFFFFFFFF100000000000002525252525FFFFFFFFFFFFFFFFFFFF0000FFFF0000000000000000008C6D8C8C8C4B4B4B0000FFFFFFFFFFB798981F000045000000000000ED00BCBC00FFFFFF8900FFFFFFFF00DEDEDEFF00830000000000");
	//BN_hex2bn(&m, "1f");
	//BN_hex2bn(&b, "5F000000000000FFFFFFFFF3F300000000FFFFFFFFFFFFFFFF00000000A9A9E5E5E5E500FFB5B0FF00000000000000FFBCBC00000000FFB6B6FFFDFDFFFF0000FF23FF95955757570000BC66FF0000ADFFFFFF6EFFFF7E00000000000000FFDCDC7A7A7A7A7A7A7AD2FFFFFFFFFFFFFF00FF00C2C2C2C26C6CFFFFFF00000000");
	
	//  BN_hex2bn(&moood, "d01");
	BN_hex2bn(&p, "800000000000000000000000000000000000000000000000000000000000000000010a1");
	
    
  
//1024bit素数
	//BN_hex2bn(&p, "7624BD1E58D6C3E3DDC4EE97ECA8259C50CA153ED3D75CE30177659F59BA7AFBB1C0AE35780C1E24A8769076371361B664138271CD96F3F51A8F62DFCFA24E8DBDD36377273597E2539890B2F5CF29BA2D343A8D79923F2070A4FED31B727A6BB2209F8E6B61AA7520791D33BF53C75F8E54C5B0A12824177264221406DC7907");
	// BN_hex2bn(&p, "68A63C7FA6A798048FE7D5DF35FED599389E0B5108C74CF2EDD3B274CBDB6FCCA8F993635C0B91F7AAA89B30EEC6C086C6AFFA72B47FBF774C24F48E67E3DCC603149BB168CEF4D97C93867F8364C4523920BDE19AA7BD6F651554EE4AB0886B8796FE7FF78DFE9F500721059F90142A3AD63FAD469DD69EEC7A2FEB48F27537");//1023bit素数
	//BN_hex2bn(&p, "7AB5B1BE284027492B76EFDB411674E368F7C16B0260D43B4E2875E251B0AF39B9D660E2585AB25F7A70A27A883457E8808026431337ECC4F8BBFBEA82801B180CAEAFB1FF3F3E6AE9E0DE4BAD740D51FC9713A50D355185FDC562FC9B80153A3DF74C36357CC12DEC281EE47B2262D8E72B040A9549CA2ED549B2E38B7212C5");//1023bit素数
//2048bit素数
	// BN_hex2bn(&p, "6C8949B02F4636FCA680DF0528553137BAF9A8F1E423D26CDC22D6E8FD470608702F363B1CF2D8616EBD78D99EA0D8C27C105633089D291DA8A400808CCCE13D0691CD78397F1578BD29626C045BFCF0B31FD10B3839BCEB81402703DD6F9A91C5304A89D4C8963B3CF8A8B8251B1760EB26428236C8DEE6B308D6552B6FD4898D2BBE4463A5378C64547FAA8BE193D7400A8F6E5FA6D6C5C2F0ED35E0DFB2E9EC9EC60934A8A0FC34D53FBC5A504E39475108AE73DEA496F4ABCE7AF9B06DBEDB06446AEEF20A196DDCCDE59889517189C65C49D196C748794BA683C207D02BA3F718F53174AE41263CC3BE79C779FCB74752ADED6DEFD6ACB8EE7C8B180FC7");
	//BN_hex2bn(&p, "6F14C4FF51E584F07027D22EBFA8FFC69DD8BC52DF0E3C021819210A68A44309C0C74008BEBABE3CC0290FA74A5A97DFCB7CE3FB79FAC859BFF9B40AAC04F7B4155D8CF69BC585436607D97E9E03BC71261EEB0EF838A1254B8747DD3BD4722C80F23DEE3FDA2446AA4B2C31D097D45EAC0C9A9F5D11A75C55FED9DA2028506791353A3C517FFB21B7A43F14720206DE9E8E5EA6EAC2FE86D2EB12398F77F7C78BB2455FBFDD731CF5AC73D60F07C9EC8574D95220D85F08ECD442E99B9B1FAA99C3FE025C2E47E437DB6D7755F8A421908A8B7844B72FC446FF2912041E1338E7835BEE46917162382F7393F2705DA95DE64E9D46DD6DB39D232701FC596A13");
	//BN_hex2bn(&p, "6E0CB07D0A136243FED6103C2A1C04056B6C6C9CF70F96C57EDB9D225C34E81789A675DC09EDC974B62EA3C5D2C7C6EA644A76CC013E93A5BFA77B7592E5A8CF5A86216F33960511B31646FBCEB85037F8880E5800A7B30A9E3C333FDCAA1F17193CE3872112C5AB67283FA3E0ADFD05102D19CAD9FABCF8490F43DB1338FD45970C1B749A4E05189582BB8355D354995E0873BB0F98A09383665249359BCC07B263534B148CF9313D28814153E80AF403AE89596EFC8CF3DBC4EB269F0B2F02CE3ACD6DF1CBDEC6F7973741D0493C40F3C541784CAE9F26E7B0A378462AAC4BB9F27C5236BB64C336429B4B3C40B4CA18586A7384F753AD4374C04212B3AB11");
//4096bit素数
	//BN_hex2bn(&p, "ED74F4ECA2CBA1A0C1F793F3D063D596F9F30B9FD6BD74AF6F592E74A4AA2E7AB9EBC2E9EB897B597EB12EE9708C4715316BE3E44E7194A253D67BEF766484583B76D5ED7B9553BF3FE54195709B742AA25C4B86E4F14946C624577FE18D4E63E0C59974E0419395F63B7B1434BDED3665D5719C0EDB03F01580E7E8FE9E3D962B719649F681A1CE07AC4183FB592E140AD1223E63982BB9897684B2B70F83BC173DB3E66B576ABCE9DEEC7FA0F5D7C73D55084BD4407FC74249798B303E3E29EACFB8860B2BF0A7866EF2102FFB83FA27DD31C5B5905E981FB0C44982E63DDDAFE9CBDE4EDB5526E32C0187E2FDDCBB13A043A6288703CDB0063D596FEEAB0BA8461A230FE9EABC70EC03B00401F3D949786F1E2959E2F3CC23721F888F116067588CB64D69641A78E786B266D9C36552D54F25D424CD579456A02E03F820B5913CA2467E9B91DDDC0240E7750B5D556756FB7279F2E73EF939964A6A820FDB21D8372E3A213D72BE95B8A7F9D9D39C3D7417D2125917B2ABF3AE222E493F86FB6885CAB5E86DBB63DEF41FE7345C26BDC73E07E456AC45F7ECEFF2DAC682E423893254E2ADE3032DE6C9BB6334CEE78A12B85C0C14ACE8E862D56831FBD178EFD61C922C994CB0634E40F95E3B32E86A4A831D754FCABCD75439E7FDA85061224884147988E1A6B346C7C7EE6C81D00F50D745C84D4784B0DD8D7FD5812E93");
	//BN_hex2bn(&p, "C57EA39604BCA42CE414AAF500BD7FB4B1841DF13D6423AA4C8D2C4C451E110AA7EBBE278E405BF39487CCBB8453E1EE133559F32F7775C11F50B0C9587947ECF06D5079B566D66A980D6E5D29B9A81C928C696FF937A385AC559F70B058CD48E70711A49B95B56F26DBB67752456075D50EC407A9C8E2F48BF9EBAE092F41A5600F6FD2A46933FD9630C4DA39DFAD43834D937E5D76C7939FAF678DA425A5C4A11114F59292F632B4AE01677D3015EA6E8EDAF7D3C2F53E96251DB93C0539BED1FB3E833CC8D6D79985AB0BEBB9B2DA34A2580D793FDA569C4C08415E71719EC9984E6CDEAD4B6B00CE480AE131BF147E4D0EC2A490BFC356DF93B4CFE80932ED3F19CD91077B226C5D1DDD238D820DD134849093BB2453FA5003A57D493D8282AD5B78180F449B8A3DE1E1CC5E8C2C3728D95B7AC928B221103FF7829F21F5773DFA96321576A15DCB273D3C6C952191602ED120D765ED9DAD160595D7D6703619A6DDCAEABAB5224AA6908F814319317604524005ABF6A79028BEBC7FEE6B101A71C6986A360C3361DFF4632A45326C6188BF55CD3E0B08184E125910CE2281BD62B4047C4D2EFD8248AFDA2905B8EE77CEF9925349D9688E57159E6C5C413C82DE1E2F4FB2DED6F531A97A4BC4DB7B1CE066DF75F5EA863485A7E8E5F46187907CFF3529EEA2A558922EC44A6A9EDC94099CE4689AF8CB850C95141C5197");
	//BN_hex2bn(&p, "ED74F4ECA2CBA1A0C1F793F3D063D596F9F30B9FD6BD74AF6F592E74A4AA2E7AB9EBC2E9EB897B597EB12EE9708C4715316BE3E44E7194A253D67BEF766484583B76D5ED7B9553BF3FE54195709B742AA25C4B86E4F14946C624577FE18D4E63E0C59974E0419395F63B7B1434BDED3665D5719C0EDB03F01580E7E8FE9E3D962B719649F681A1CE07AC4183FB592E140AD1223E63982BB9897684B2B70F83BC173DB3E66B576ABCE9DEEC7FA0F5D7C73D55084BD4407FC74249798B303E3E29EACFB8860B2BF0A7866EF2102FFB83FA27DD31C5B5905E981FB0C44982E63DDDAFE9CBDE4EDB5526E32C0187E2FDDCBB13A043A6288703CDB0063D596FEEAB0BA8461A230FE9EABC70EC03B00401F3D949786F1E2959E2F3CC23721F888F116067588CB64D69641A78E786B266D9C36552D54F25D424CD579456A02E03F820B5913CA2467E9B91DDDC0240E7750B5D556756FB7279F2E73EF939964A6A820FDB21D8372E3A213D72BE95B8A7F9D9D39C3D7417D2125917B2ABF3AE222E493F86FB6885CAB5E86DBB63DEF41FE7345C26BDC73E07E456AC45F7ECEFF2DAC682E423893254E2ADE3032DE6C9BB6334CEE78A12B85C0C14ACE8E862D56831FBD178EFD61C922C994CB0634E40F95E3B32E86A4A831D754FCABCD75439E7FDA85061224884147988E1A6B346C7C7EE6C81D00F50D745C84D4784B0DD8D7FD5812E93");
  
//------------------------随机数生成------------------------------------//
	// int m = 284; // 假设 GF2m的 m为4
	//int top = 0; //top = -1表示最高位设置为0, top = 0表示最高位设置为1,top=1时最高两位都设置成1，
	//int bottom = 0; //bottom:不为0时，可以生成奇的随机数
	//int bits=24;

   //以随机数形式赋值
	//BN_bntest_rand(a, bits, top, bottom);		
	//BN_bntest_rand(p, bits, top, bottom);  
	//BN_bntest_rand(m, bits, top, bottom);
   
   //生成 GF(2^m) 域内的随机数a//
	//BN_rand(rand_num, bits, top, 1);    // 生成bits位的随机数
	// BN_set_bit(modulus, m);          // 设置 modulus 为 2^m
	//BN_mod(a, c, modulus, ctx);   // a=rand_num mod modulus -> GF(2^m) 域内的数
	
	//生成 GF(2^m) 域内的随机数b//
	//BN_rand(rand_num, bits, top, 1);    
	//BN_set_bit(modulus, m);          
	//BN_mod(b, rand_num, modulus, ctx);   
   
     //生成bits位的素数//
     //BN_generate_prime_ex(moood, bits, 10, NULL, NULL, NULL);//

//------------------------普通BN运算------------------------------------//
	//BN_mul(r, a, b, ctx);
	// BN_set_bit(modulus, m);
	//BN_mod(r, c, modulus, ctx);   // r=c mod modulus -> GF(2^m) 域内的数
//-----------------------蒙哥马利域------------------------------------//
	//BN_MONT_CTX_set(mont, moood, ctx);//利用给定大数mod设置好Montgomery模数中相关信息——ri,RR,N,Ni,n0。
	//BN_to_montgomery(mont_a, a, mont, ctx);//a = mont_a*R mod mont
	//BN_hex2bn(&b, "1");
	//BN_mod_mul_montgomery(r0, mont_a, mont_a, mont, ctx);// r=a*b mod mont
	//BN_mod_mul_montgomery(r, r0, mont_a, mont, ctx);// r=a*b mod mont
	//BN_to_montgomery(r0,b, mont, ctx);
	//for(int i=0;i<16;i++){
	//  BN_mod_mul_montgomery(r0, r0, mont_a, mont, ctx);// r=a*b mod mont
	//}
	//BN_from_montgomery(r, r0, mont, ctx);
//------------------------素数域运算------------------------------------//
	BN_mod_add(r, a, b, p, ctx);    //模加 r=a+b mod p
	//BN_mod_sub(r, a, b, p, ctx);    //模减 r=a-b mod p
	// BN_mod_mul(r, a, b, p, ctx);   //模乘 r= a*b mod p
	// BN_mod_sqr(r, mont_a, p, ctx);       //模平方 r= a*a mod p
	//BN_mod_inverse(r, a, p, ctx);   //模逆 r=1/a mod p
	//BN_mod_exp_simple(r, a, m, p, ctx);// 模幂r= a^m  mod p

//------------------------ GF2m/二进制域运算 --------------------------------//
	//BN_mod(r, a, modulus, ctx);   // r=c mod modulus -> GF(2^m) 域内的数 
	//BN_GF2m_add(r0, a, b);   // 相加 c=a+b
	//BN_GF2m_mod(r, r0, p);  // 模运算 r=c mod p
	// BN_GF2m_mod_sqr(r, b, p, ctx);    //模平方 r=a*a mod p
	//BN_GF2m_mod_sqr(r, b, p, ctx);    //模平方 r=a*a mod p
	//BN_GF2m_mod_mul(r, a, b, p, ctx);   //模乘 r=a*b mod p
	//BN_GF2m_mod_inv(r, a, p, ctx);    //模逆 r=1/a mod p
	
//--------------------曲线---------------------///
	//------------------ 创建自定义椭圆曲线----------------///
    //EC_GROUP* custom_group = EC_GROUP_new_curve_GFp(custom_p, custom_a, custom_b, NULL); 	//素数域曲线
	//EC_GROUP* custom_group = EC_GROUP_new_curve_GF2m(custom_p, custom_a, custom_b, NULL);  //二进制域曲线
	//---------------- 创建椭圆曲线上投影坐标点------------------//
    //EC_POINT* point = EC_POINT_new(custom_group);			//空白点
    //EC_POINT* result = EC_POINT_new(custom_group);	// 创建用于存储结果的点
	//------------------ 将十六进制字符串转换为BIGNUM并赋值-------------//
	/*BIGNUM* hex_string_to_bn(const char* hex) {
    BIGNUM* bn = BN_new();
    if (!bn || !BN_hex2bn(&bn, hex)) {
        fprintf(stderr, "Error converting hex to BIGNUM\n");
        exit(EXIT_FAILURE);
    }
    return bn;
	}*/
    //BIGNUM* x = hex_string_to_bn("32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7");
    //BIGNUM* y = hex_string_to_bn("BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0");
    //BIGNUM* z = hex_string_to_bn("1");
	//------------------ 设置点的投影坐标-------------//
    //EC_POINT_set_Jprojective_coordinates_GFp(custom_group, point, x, y, z, NULL);	  //素数域
	//------------------ 设置点的仿射坐标-------------//
    //EC_POINT_set_affine_coordinates_GFp (custom_group, point, x, y, NULL);	  			//素数域
    //EC_POINT_set_affine_coordinates_GF2m(custom_group, point, x, y, NULL);  		//二进制域
	//-----------------------点运算----------------------------//
	//EC_POINT_add(custom_group, result, point1, point2, NULL);  	//点加 result=point1+point2
	//EC_POINT_dbl(custom_group, result, point, NULL);				//倍点 result=point+point
	//EC_POINT_mul(custom_group, result, NULL, point, scalar, NULL);	//点乘 result=scalar*point
	

  
    //-------------------------- 打印定义 -----------------------------------//
   //show以二进制打印随机生成的数
	//char* showa;
	//char* showb;
	//char* showp;
	//char* showm;
	
	//showa = BN_bn2hex(a);
	//showb = BN_bn2hex(b);
	//showp = BN_bn2hex(p);
	//showm = BN_bn2hex(m);
	// 获取结果的坐标
		//BIGNUM* result_x = BN_new();
		//BIGNUM* result_y = BN_new();
		//BIGNUM* result_z = BN_new();
		//EC_POINT_get_Jprojective_coordinates_GFp(custom_group, result, result_x, result_y, result_z, NULL);
	
	// printf("位宽:%d\n输入:\na=%s\n模数：p=%s\n", length, showa, showp);      //模逆
	//printf("位宽:%d\n输入:\na=%s\n模数：p=%s\n幂数：m=%s\n", length, showa, showp,showm);      //模幂
	//printf("位宽:%d\n 输入：\n   a=%s\n  b=%s\n 模数：\np=%s\n", length, showa,showb,showp);
	//printf("位宽:%d\n 输入：\n   a=%s\n  mod=%s\n", length, showa, showp);        //蒙哥马利
	// 获取模运算的结果
	//char* c_str = BN_bn2hex(mont_a);
	//printf("输出：\n   mont_a = %s\n", c_str);
	char* r_str = BN_bn2hex(r);
	printf("r：\n   r = %s\n", r_str);
   
    //--------------------释放资源---------------------------------// 
   //BN_free(a);
   //BN_free(p);
   //BN_free(r);		
   //BN_MONT_CTX_free(mont);			//释放蒙哥马利ctx
   //BN_CTX_free(ctx);					//释放ctx
   //EC_POINT_free(point1);				//释放点		
   //EC_GROUP_free(custom_group);		//释放曲线

    return 0;
}
